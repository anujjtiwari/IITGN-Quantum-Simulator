<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IITGN QuantumLab - Interactive Simulator</title>
    <link rel="icon" type="image/png" href="images\iitgn-logo.png">
    <!-- Tailwind CSS CDN --><script src="https://cdn.tailwindcss.com"></script>
    <!-- jsqubits (Quantum Simulator) CDN (no longer required for core sim but kept if you want it) -->
    <script src="https://cdn.jsdelivr.net/npm/jsqubits@1.7.0/dist/jsqubits.min.js"></script>
    <!-- Google Fonts --><link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Source+Code+Pro:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- Custom Styles --- */
        :root {
            --bg-dark: #0a0f2d;
            --bg-medium: #111827; /* gray-900 */
            --bg-light: #1f2937;  /* gray-800 */
            --text-primary: #f3f4f6;
            --text-secondary: #9ca3af;
            --accent-blue: #00bfff;
            --accent-purple: #8a2be2;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-medium);
            color: var(--text-primary);
            /* cursor: none; */ 
        }

        /* --- Interactive Canvas Background --- */
        #interactive-bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Behind content, in front of body bg */
        }

        /* --- Glowing Cursor Orb --- */
        #cursor-orb {
            position: fixed;
            top: 0;
            left: 0;
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(0, 191, 255, 0.15) 0%, rgba(0, 191, 255, 0) 60%);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease-out;
            z-index: 5; /* Above canvas, below content */
            opacity: 0;
            animation: fadeIn 1s forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Make all content sit above the canvas and orb */
        header, main, footer {
            position: relative;
            z-index: 10;
        }
        /* Sticky header needs a higher z-index */
        header {
            z-index: 50;
        }


        /* --- Typography & Elements --- */
        .font-code {
            font-family: 'Source Code Pro', monospace;
        }
        .text-glow {
            text-shadow: 0 0 8px var(--accent-blue);
        }
        
        /* --- 3D Tilt Cards --- */
        .perspective-card {
            transform-style: preserve-3d;
            transition: transform 0.4s ease-out;
        }
        .perspective-card:hover {
            transform: perspective(1000px) rotateX(5deg) rotateY(-8deg) scale(1.05);
        }

        /* --- Simulator Styles --- */
        .gate {
            font-family: 'Source Code Pro', monospace;
            background-color: var(--accent-blue);
            color: var(--bg-dark);
            border: 1px solid var(--accent-blue);
            transition: all 0.2s ease;
        }
        .gate:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--accent-blue);
        }
        .gate-measure {
            background-color: var(--accent-purple);
            border-color: var(--accent-purple);
        }
        .gate-measure:hover {
            box-shadow: 0 0 15px var(--accent-purple);
        }

        .drop-zone {
            width: 50px;
            height: 50px;
            border-right: 1px dashed #4b5563; /* gray-600 */
            transition: background-color 0.2s ease;
        }
        .drop-zone.drag-over {
            background-color: rgba(0, 191, 255, 0.2); /* Highlight on drag over */
        }
        .drop-zone.gate-placed {
            font-family: 'Source Code Pro', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: var(--bg-dark);
            border: 1px solid var(--accent-blue);
        }
        /* CNOT-specific styles */
        .gate-cnot-control {
            background-color: #f9a8d4 !important; /* Pinkish */
            border-color: #f472b6 !important;
        }
        .gate-cnot-target {
            background-color: #f9a8d4 !important; /* Pinkish */
            border-color: #f472b6 !important;
        }

        
        /* --- Probability Bar Animation --- */
        .prob-bar-inner {
            transition: width 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        /* --- Logo Glow --- */
        .iitgn-logo-hero {
            filter: drop-shadow(0 0 15px var(--accent-blue)) drop-shadow(0 0 5px var(--accent-blue));
        }
    </style>
</head>
<body class="relative overflow-x-hidden">

    <!-- NEW Interactive Canvas Background -->
    <canvas id="interactive-bg-canvas"></canvas>

    <!-- Glowing Cursor Orb --><div id="cursor-orb"></div>

    <!-- Header --><header class="sticky top-0 z-50 w-full bg-gray-900/70 backdrop-blur-md border-b border-gray-700">
        <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
            <div class="flex items-center gap-3">
                <img src="images\iitgn-logo.png" alt="IITGN Logo" class="h-10 w-10 rounded-full">
                <div class="text-2xl font-bold text-white text-glow">
                    IITGN QuantumLab
                </div>
            </div>
            <div class="space-x-6">
                <a href="#home" class="text-gray-300 hover:text-white transition-colors">Home</a>
                <a href="#simulator" class="text-gray-300 hover:text-white transition-colors">Simulator</a>
                <a href="#about" class="text-gray-300 hover:text-white transition-colors">About</a>
            </div>
        </nav>
    </header>

    <!-- Main Content --><main>

        <!-- === HOME SECTION === --><section id="home" class="min-h-screen flex items-center justify-center py-20 relative overflow-hidden">
            <!-- Removed old glowing DIVs -->

            <div class="container mx-auto px-6 text-center relative z-20">
                <!-- MODIFICATION: Big IITGN Logo --><img src="images\iitgn-logo.png" alt="IITGN Large Logo" class="iitgn-logo-hero h-32 w-32 md:h-40 md:w-40 mx-auto mb-8 rounded-full">

                <h1 class="text-5xl md:text-7xl font-bold text-white mb-4">
                    Explore the <span class="text-glow text-cyan-400">Quantum Realm</span>
                </h1>
                <p class="text-xl md:text-2xl text-gray-300 mb-6">
                    An initiative by <strong>Prof. Sameer G Kulkarni</strong>, IIT Gandhinagar.
                </p>
                <p class="text-lg text-gray-400 max-w-2xl mx-auto mb-10">
                    Dive into the world of quantum computing and QML. Experiment with circuits, visualize probabilities, and build your understanding with our interactive simulator.
                </p>
                <a href="#simulator" class="bg-cyan-500 text-gray-900 font-bold py-3 px-8 rounded-lg text-lg hover:bg-cyan-400 hover:shadow-lg hover:shadow-cyan-500/30 transition-all duration-300 transform hover:scale-105">
                    Launch Simulator
                </a>
            </div>
        </section>

        <!-- === FEATURES SECTION === --><section id="features" class="py-24 bg-gray-900">
            <div class="container mx-auto px-6">
                <h2 class="text-4xl font-bold text-center text-white mb-16">Key Features</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8">
                    
                    <!-- Card 1 --><div class="perspective-card bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-700">
                        <div class="flex items-center justify-center h-16 w-16 bg-gray-700 rounded-full mb-4 shadow-inner">
                            <svg class="w-8 h-8 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4
0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        </div>
                        <h3 class="text-2xl font-semibold text-white mb-2">Interactive Simulator</h3>
                        <p class="text-gray-400">Build and test quantum circuits in real-time with an intuitive UI.</p>
                    </div>

                    <!-- Card 2 --><div class="perspective-card bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-700">
                        <div class="flex items-center justify-center h-16 w-16 bg-gray-700 rounded-full mb-4 shadow-inner">
                            <svg class="w-8 h-8 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 3.055A9.001 9.001 0 1020.945 13H11V3.055z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.488 9H15V3.512A9.025 9.025 0 0120.488 9z"></path></svg>
                        </div>
                        <h3 class="text-2xl font-semibold text-white mb-2">Real-time Results</h3>
                        <p class="text-gray-400">Instantly visualize state probabilities with dynamic charts.</p>
                    </div>

                    <!-- Card 3 --><div class="perspective-card bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-700">
                        <div class="flex items-center justify-center h-16 w-16 bg-gray-700 rounded-full mb-4 shadow-inner">
                            <svg class="w-8 h-8 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 003 0m0 0V14m0-2.5v-6a1.5 1.5 0 013 0m0 0V14m0-2.5v-6a1.5 1.5 0 013 0m0 0v6a1.5 1.5 0 01-3 0m0 0v-6a1.5 1.5 0 013 0"></path></svg>
                        </div>
                        <h3 class="text-2xl font-semibold text-white mb-2">Drag & Drop UI</h3>
                        <p class="text-gray-400">An intuitive interface inspired by IBM's Quantum Composer.</p>
                    </div>

                    <!-- Card 4 --><div class="perspective-card bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-700">
                        <div class="flex items-center justify-center h-16 w-16 bg-gray-700 rounded-full mb-4 shadow-inner">
                            <svg class="w-8 h-8 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                        </div>
                        <h3 class="text-2xl font-semibold text-white mb-2">Custom Qubits</h3>
                        <p class="text-gray-400">Add or remove qubits to match your specific experiment.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- === SIMULATOR SECTION === --><section id="simulator" class="min-h-screen py-20 bg-gray-900/50">
            <div class="container mx-auto px-6 h-full">
                <h2 class="text-4xl font-bold text-center text-white mb-10">Quantum Circuit Simulator</h2>
                
                <div class="flex flex-col lg:flex-row gap-6 h-full max-w-7xl mx-auto bg-gray-800 rounded-lg shadow-2xl p-6 border border-gray-700">
                    
                    <!-- COLUMN 1: GATE PALETTE --><aside class="w-full lg:w-1/5 bg-gray-900 p-4 rounded-lg border border-gray-700">
                        <h3 class="text-xl font-semibold text-white mb-4">Gate Palette</h3>
                        <div class="space-y-4">
                            <div>
                                <h4 class="text-sm font-code text-gray-400 mb-2 uppercase">Pauli Gates</h4>
                                <div class="grid grid-cols-3 gap-2">
                                    <div id="gate-x" data-gate="X" class="gate w-12 h-12 flex items-center justify-center rounded-md cursor-grab" draggable="true">X</div>
                                    <div id="gate-y" data-gate="Y" class="gate w-12 h-12 flex items-center justify-center rounded-md cursor-grab" draggable="true">Y</div>
                                    <div id="gate-z" data-gate="Z" class="gate w-12 h-12 flex items-center justify-center rounded-md cursor-grab" draggable="true">Z</div>
                                </div>
                            </div>
                            <div>
                                <h4 class="text-sm font-code text-gray-400 mb-2 uppercase">Clifford Gates</h4>
                                <div class="grid grid-cols-3 gap-2">
                                    <div id="gate-h" data-gate="H" class="gate w-12 h-12 flex items-center justify-center rounded-md cursor-grab" draggable="true">H</div>
                                    <div id="gate-s" data-gate="S" class="gate w-12 h-12 flex items-center justify-center rounded-md cursor-grab" draggable="true">S</div>
                                    <div id="gate-t" data-gate="T" class="gate w-12 h-12 flex items-center justify-center rounded-md cursor-grab" draggable="true">T</div>
                                </div>
                            </div>
                            <div>
                                <h4 class="text-sm font-code text-gray-400 mb-2 uppercase">Multi-Qubit</h4>
                                <div class="grid grid-cols-3 gap-2">
                                    <div id="gate-cnot" data-gate="CX" class="gate w-12 h-12 flex items-center justify-center rounded-md cursor-grab text-sm" draggable="true">CX</div>
                                    <div id="gate-swap" data-gate="SWAP" class="gate w-12 h-12 flex items-center justify-center rounded-md cursor-grab text-sm" draggable="true">SWAP</div>
                                </div>
                            </div>
                            <div>
                                <h4 class="text-sm font-code text-gray-400 mb-2 uppercase">Other</h4>
                                <div class="grid grid-cols-3 gap-2">
                                    <div id="gate-measure" data-gate="M" class="gate gate-measure w-12 h-12 flex items-center justify-center rounded-md cursor-grab" draggable="true">M</div>
                                </div>
                            </div>
                        </div>
                    </aside>

                    <!-- COLUMN 2: CIRCUIT EDITOR --><main class="w-full lg:w-3/5 bg-gray-900 p-4 rounded-lg border border-gray-700 overflow-hidden">
                        <div class="flex items-center gap-4 mb-4 pb-4 border-b border-gray-700">
                            <button id="add-qubit-btn" class="bg-cyan-600 hover:bg-cyan-500 text-white font-semibold py-2 px-4 rounded-lg transition-colors">
                                + Add Qubit
                            </button>
                            <button id="run-btn" class="bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-6 rounded-lg transition-colors">
                                ▶ RUN
                            </button>
                            <button id="clear-btn" class="bg-red-600 hover:bg-red-500 text-white font-semibold py-2 px-4 rounded-lg transition-colors">
                                Clear
                            </button>
                        </div>
                        <div id="circuit-canvas" class="space-y-3 overflow-x-auto pb-4">
                            <!-- Qubit lines will be dynamically added here by JS --></div>
                    </main>

                    <!-- COLUMN 3: RESULTS PANEL --><aside class="w-full lg:w-1/5 bg-gray-900 p-4 rounded-lg border border-gray-700">
                        <h3 class="text-xl font-semibold text-white mb-4">Results</h3>
                        <div class="bg-gray-800 p-4 rounded-lg shadow-inner">
                            <h4 class="text-md font-semibold text-gray-200 mb-3">Probability Distribution</h4>
                            <div id="prob-chart" class="space-y-2 font-code text-sm">
                                <!-- Probabilities will be dynamically added here by JS --></div>
                        </div>
                        
                        <div class="bg-gray-800 p-4 rounded-lg shadow-inner mt-4">
                            <h4 class="text-md font-semibold text-gray-200 mb-3">Bloch Sphere (q[0])</h4>
                            <div class="flex justify-center items-center h-40">
                                <svg class="w-32 h-32" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="50" cy="50" r="48" fill="none" stroke="#4b5563" stroke-width="2"/>
                                    <ellipse cx="50" cy="50" rx="48" ry="20" fill="none" stroke="#4b5563" stroke-width="1.5" stroke-dasharray="3 3"/>
                                    <line x1="50" y1="2" x2="50" y2="98" stroke="#6b7280" stroke-width="1.5"/>
                                    <text x="50" y="10" fill="#9ca3af" font-size="8" text-anchor="middle">|0⟩</text>
                                    <text x="50" y="95" fill="#9ca3af" font-size="8" text-anchor="middle">|1⟩</text>
                                    <!-- Animated State Vector --><line id="bloch-vector" x1="50" y1="50" x2="70" y2="40" stroke="#00bfff" stroke-width="2.5" stroke-linecap="round"/>
                                    <circle id="bloch-head" cx="70" cy="40" r="3" fill="#00bfff"/>
                                </svg>
                            </div>
                        </div>
                    </aside>
                </div>
            </div>
        </section>

        <section id="quirk-simulator" class="py-20 bg-gray-800/50">
            <div class="container mx-auto px-6 h-full">
                
                <h2 class="text-4xl font-bold text-center text-white mb-10">
                    Quantum Simulator
                </h2>
                
                <div class="max-w-7xl mx-auto bg-gray-800 rounded-lg shadow-2xl p-6 border border-gray-700">
                    
                    <iframe 
                        src="/new/index.html" 
                        class="w-full h-[800px] rounded-lg border-2 border-gray-700"
                    >
                    </iframe>
                    <div class="text-center mt-6">
                        <a href="/new/index.html" target="_blank"
                           class="bg-cyan-500 text-gray-900 font-bold py-3 px-6 rounded-lg hover:bg-cyan-400 transition-all duration-300">
                            Open Full Screen
                        </a>
                    </div>

                </div>
            </div>
        </section>

        <!-- === ABOUT SECTION === --><section id="about" class="py-24 bg-gray-900">
            <div class="container mx-auto px-6 max-w-3xl text-center">
                <h2 class="text-4xl font-bold text-white mb-6">About This Initiative</h2>
                <p class="text-lg text-gray-300 leading-relaxed">
                    IITGN QuantumLab is a dedicated platform, born from the vision of 
                    <strong class="text-cyan-400">Prof. Sameer G Kulkarni</strong> 
                    at the Indian Institute of Technology Gandhinagar. Our mission is to demystify
                    quantum computing and quantum machine learning, providing an accessible, hands-on
                    learning environment for students, researchers, and enthusiasts.
                </p>
            </div>
        </section>
    </main>

    <!-- Footer --><footer class="bg-gray-900 border-t border-gray-700 py-8">
        <div class="container mx-auto px-6 text-center text-gray-500">
            <p>&copy; 2025 IIT Gandhinagar. All rights reserved. An initiative by Prof. Sameer G Kulkarni.</p>
        </div>
    </footer>

    <!-- === JAVASCRIPT LOGIC === --><script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- 1. Glowing Cursor Orb ---
            const orb = document.getElementById('cursor-orb');
            document.addEventListener('mousemove', (e) => {
                orb.style.transform = `translate(${e.clientX}px, ${e.clientY}px) translate(-50%, -50%)`;
            });

            // --- DOM references for simulator ---
            const circuitCanvas = document.getElementById('circuit-canvas');
            const addQubitBtn = document.getElementById('add-qubit-btn');
            const runBtn = document.getElementById('run-btn');
            const clearBtn = document.getElementById('clear-btn');
            const probChart = document.getElementById('prob-chart');
            let qubitCount = 0;
            const gateSlotsPerQubit = 15;

            // --- Complex number helpers ---
            function c(re, im=0){ return {re: re, im: im}; }
            function cAdd(a,b){ return {re: a.re + b.re, im: a.im + b.im}; }
            function cSub(a,b){ return {re: a.re - b.re, im: a.im - b.im}; }
            function cMul(a,b){ return { re: a.re*b.re - a.im*b.im, im: a.re*b.im + a.im*b.re }; }
            function cScale(a, s){ return { re: a.re * s, im: a.im * s }; }
            function cConj(a){ return { re: a.re, im: -a.im }; }
            function cAbs2(a){ return a.re*a.re + a.im*a.im; }

            // --- Create a |0...0> state vector ---
            function zeroState(n) {
                const N = 1<<n;
                const state = Array(N).fill(null).map(()=>c(0,0));
                state[0] = c(1,0);
                return state;
            }

            // --- Apply a single-qubit gate (2x2 complex matrix) on qubit `qb` (0 = top line) ---
            function applySingleQubitGate(state, n, qb, matrix) {
                const N = state.length;
                const out = Array(N).fill(null).map(()=>c(0,0));
                // qubit index mapping: q[0] is top (most-significant) or least? In UI q[0] is shown at top, we will map qubit 0 -> most-significant bit
                // We'll treat qubit numbering so that bit position = (n-1 - qb) in integer indexing.
                const bit = n - 1 - qb;
                for (let idx = 0; idx < N; idx++) {
                    const bitVal = (idx >> bit) & 1;
                    // basis |0> contributes
                    const amp = state[idx];
                    if (bitVal === 0) {
                        // it remains in same index for output(0) and maps to flipped for output(1)
                        // new0 = m00*old0 + m01*old1
                        // old1 is at idx_with_bit1
                        const idx1 = idx | (1 << bit);
                        const amp1 = state[idx1];
                        // add to out[idx] (target bit 0)
                        const term0 = cMul(matrix[0][0], amp);
                        const term1 = cMul(matrix[0][1], amp1);
                        out[idx] = cAdd(out[idx], term0);
                        out[idx] = cAdd(out[idx], term1);
                        // add to out[idx1] (target bit 1)
                        const term2 = cMul(matrix[1][0], amp);
                        const term3 = cMul(matrix[1][1], amp1);
                        out[idx1] = cAdd(out[idx1], term2);
                        out[idx1] = cAdd(out[idx1], term3);
                    }
                }
                return out;
            }

            // --- Apply CNOT (control qb_c, target qb_t). qb numbering same as above. ---
            function applyCNOT(state, n, qb_c, qb_t) {
                const N = state.length;
                const out = Array(N).fill(null).map(()=>c(0,0));
                const bitC = n - 1 - qb_c;
                const bitT = n - 1 - qb_t;
                for (let idx = 0; idx < N; idx++) {
                    const control = ((idx >> bitC) & 1);
                    if (control === 1) {
                        // flip target bit
                        const flipped = idx ^ (1 << bitT);
                        out[flipped] = cAdd(out[flipped] || c(0,0), state[idx]);
                    } else {
                        out[idx] = cAdd(out[idx] || c(0,0), state[idx]);
                    }
                }
                return out;
            }

            // --- Apply SWAP between two qubits (qb1,qb2) ---
            function applySWAP(state, n, qb1, qb2) {
                const N = state.length;
                const out = Array(N).fill(null);
                const bit1 = n - 1 - qb1;
                const bit2 = n - 1 - qb2;
                for (let idx = 0; idx < N; idx++) {
                    const b1 = (idx >> bit1) & 1;
                    const b2 = (idx >> bit2) & 1;
                    if (b1 === b2) {
                        out[idx] = state[idx];
                    } else {
                        // swap bits -> compute swapped index
                        const swapped = idx ^ ((1<<bit1) | (1<<bit2));
                        out[swapped] = state[idx];
                    }
                }
                // fill any nulls with zero
                for (let i=0;i<N;i++) if (!out[i]) out[i] = c(0,0);
                return out;
            }

            // --- Measurement on qubit qb: collapse probabilistically and return measured bit (0 or 1) and new state ---
            function measureQubit(state, n, qb) {
                const N = state.length;
                const bit = n - 1 - qb;
                let p0 = 0, p1 = 0;
                for (let idx=0; idx<N; idx++) {
                    const b = (idx >> bit) & 1;
                    const prob = cAbs2(state[idx]);
                    if (b === 0) p0 += prob; else p1 += prob;
                }
                // sample
                const r = Math.random();
                const measured = (r < p0) ? 0 : 1;
                // zero out inconsistent amplitudes
                const out = Array(N).fill(null).map(()=>c(0,0));
                let norm = 0;
                for (let idx=0; idx<N; idx++) {
                    const b = (idx >> bit) & 1;
                    if (b === measured) {
                        out[idx] = state[idx];
                        norm += cAbs2(state[idx]);
                    }
                }
                // renormalize
                const inv = norm > 0 ? 1/Math.sqrt(norm) : 0;
                for (let idx=0; idx<N; idx++) {
                    out[idx] = cScale(out[idx], inv);
                }
                return {state: out, bit: measured};
            }

            // --- Normalize state (in-place) ---
            function normalizeState(state) {
                let norm = 0;
                for (let i=0;i<state.length;i++) norm += cAbs2(state[i]);
                if (norm <= 0) return state;
                const inv = 1/Math.sqrt(norm);
                for (let i=0;i<state.length;i++) state[i] = cScale(state[i], inv);
                return state;
            }

            // --- Reduced density matrix for qubit 0, returns 2x2 complex matrix ---
            function reducedDensityQubit0(state, n) {
                const N = state.length;
                const bit = n - 1 - 0; // qubit 0
                // rho_00 = sum_{r} a_{0r} a_{0r}*, rho_11 = sum a_{1r}a_{1r}*, rho_01 = sum a_{0r} a_{1r}*
                let rho00 = c(0,0), rho11 = c(0,0), rho01 = c(0,0);
                for (let idx=0; idx<N; idx++) {
                    const b = (idx >> bit) & 1;
                    if (b === 0) {
                        rho00 = cAdd(rho00, cScale(state[idx], state[idx].re*0 + 0)); // placeholder, we'll add properly below
                    }
                }
                // We'll compute properly:
                rho00 = c(0,0); rho11 = c(0,0); rho01 = c(0,0);
                for (let idx=0; idx<N; idx++) {
                    const b = (idx >> bit) & 1;
                    if (b === 0) {
                        // partner index with bit flipped
                        const partner = idx | (1<<bit);
                        rho00 = cAdd(rho00, cMul(state[idx], cConj(state[idx])));
                        rho01 = cAdd(rho01, cMul(state[idx], cConj(state[partner])));
                    } else {
                        rho11 = cAdd(rho11, cMul(state[idx], cConj(state[idx])));
                    }
                }
                return [[rho00, rho01],[cConj(rho01), rho11]];
            }

            // --- Convert density matrix to Bloch vector (x,y,z) ---
            function blochFromRho(rho) {
                // rho = [[a, b], [b*, d]]
                const a = rho[0][0], b = rho[0][1], d = rho[1][1];
                const x = 2 * b.re;
                const y = -2 * b.im;
                const z = a.re - d.re;
                return {x, y, z};
            }

            // --- UI helpers: draw probability bars & Bloch vector rotation ---
            function showProbabilities(state, n) {
                probChart.innerHTML = '';
                const N = state.length;
                const probs = [];
                for (let i=0;i<N;i++){
                    probs.push({state: i.toString(2).padStart(n,'0'), prob: cAbs2(state[i])});
                }
                probs.sort((a,b)=>a.state.localeCompare(b.state)); // keep order
                for (let i=0;i<probs.length;i++){
                    const percent = probs[i].prob * 100;
                    const barHTML = `
                        <div class="flex items-center space-x-2">
                            <span class="text-gray-400 w-16">|${probs[i].state}⟩</span>
                            <div class="w-full bg-gray-700 rounded-full h-4 overflow-hidden shadow-inner">
                                <div class="prob-bar-inner bg-cyan-500 h-4 rounded-full" style="width: 0%;"></div>
                            </div>
                            <span class="text-white w-12 text-right">${percent.toFixed(1)}%</span>
                        </div>
                    `;
                    probChart.insertAdjacentHTML('beforeend', barHTML);
                }
                // animate
                setTimeout(()=>{
                    document.querySelectorAll('.prob-bar-inner').forEach((bar, i)=>{
                        bar.style.width = `${(probs[i].prob*100).toFixed(3)}%`;
                    });
                }, 80);
            }

            function updateBloch(state, n) {
                // compute reduced rho for q0
                if (n === 0) return;
                const rho = reducedDensityQubit0(state,n);
                const bloch = blochFromRho(rho);
                // Convert bloch to a rotation for the line in SVG.
                // We'll map vector (x,y,z) to a 2D projection: use x,z to set endpoint for a simple visualization
                const x = 50 + bloch.x * 20; // scale for visibility
                const y = 50 - bloch.z * 20;
                const vector = document.getElementById('bloch-vector');
                const head = document.getElementById('bloch-head');
                if (vector && head) {
                    vector.setAttribute('x2', x);
                    vector.setAttribute('y2', y);
                    head.setAttribute('cx', x);
                    head.setAttribute('cy', y);
                }
            }

            // --- Circuit UI generation and drag/drop handlers ---
            function createQubitLine(index) {
                const line = document.createElement('div');
                line.className = 'qubit-line flex items-center bg-gray-800 rounded-md p-2 shadow-inner';
                const label = document.createElement('span');
                label.className = 'font-code text-gray-400 w-20';
                label.textContent = `q[${index}]: |0⟩`;
                line.appendChild(label);
                const slots = document.createElement('div');
                slots.className = 'flex flex-nowrap';
                for (let i = 0; i < gateSlotsPerQubit; i++) {
                    const zone = document.createElement('div');
                    zone.className = 'drop-zone w-12 h-12 rounded-sm';
                    zone.dataset.q = index;
                    zone.dataset.s = i;
                    zone.addEventListener('dragover', allowDrop);
                    zone.addEventListener('dragenter', dragEnter);
                    zone.addEventListener('dragleave', dragLeave);
                    zone.addEventListener('drop', drop);
                    slots.appendChild(zone);
                }
                line.appendChild(slots);
                return line;
            }

            function addQubit() {
                const newLine = createQubitLine(qubitCount);
                circuitCanvas.appendChild(newLine);
                qubitCount++;
                updateProbChart(true);
            }

            function clearCircuit() {
                document.querySelectorAll('.drop-zone').forEach(zone => {
                    zone.innerHTML = '';
                    // Reset classes to default
                    zone.className = 'drop-zone w-12 h-12 rounded-sm';
                });
                updateProbChart(true);
            }

            // --- Drag & Drop housekeeping ---
            function allowDrop(ev) { ev.preventDefault(); }
            function dragEnter(ev) { ev.target.classList.add('drag-over'); }
            function dragLeave(ev) { ev.target.classList.remove('drag-over'); }

            function drop(ev) {
                ev.preventDefault();
                ev.target.classList.remove('drag-over');
                
                const gateId = ev.dataTransfer.getData("text");
                const gateElement = document.getElementById(gateId);
                if (!gateElement) return;
                const gateType = gateElement.dataset.gate;
                
                ev.target.innerHTML = ''; // Clear any existing text
                
                if (gateId === 'gate-cnot') {
                    // Check if a 'C' (Control) already exists in this column (step)
                    const step = ev.target.dataset.s;
                    const controlExists = document.querySelector(`.drop-zone[data-s="${step}"].gate-cnot-control`);
                    
                    if (!controlExists) {
                        // This is the first CNOT in column, make it a Control
                        ev.target.textContent = 'C';
                        ev.target.className = 'drop-zone gate-placed gate-cnot-control';
                    } else {
                        // Control exists, make this a Target
                        ev.target.textContent = 'X';
                        ev.target.className = 'drop-zone gate-placed gate-cnot-target';
                    }
                } else if (gateId === 'gate-measure') {
                    ev.target.textContent = gateType;
                    ev.target.className = 'drop-zone gate-placed bg-purple-500 border-purple-400';
                } else if (gateId === 'gate-swap') {
                    // Just mark as SWAP - pairing will occur in simulation
                    ev.target.textContent = 'SWAP';
                    ev.target.className = 'drop-zone gate-placed bg-yellow-300 border-yellow-400';
                } else {
                    // All other gates
                    ev.target.textContent = gateType;
                    ev.target.className = 'drop-zone gate-placed bg-cyan-500 border-cyan-400';
                }
            }

            document.querySelectorAll('.gate').forEach(gate => {
                gate.addEventListener('dragstart', (ev) => {
                    ev.dataTransfer.setData("text", ev.target.id);
                });
            });

            addQubitBtn.addEventListener('click', addQubit);
            runBtn.addEventListener('click', runSimulation);
            clearBtn.addEventListener('click', clearCircuit);

            // Initial setup
            addQubit();
            addQubit();

            // --- Real simulation engine (state-vector) ---
            function runSimulation() {
                if (qubitCount === 0) {
                    probChart.innerHTML = '<p class="text-gray-400 text-sm">Add qubits to run.</p>';
                    return;
                }

                // initialize |0...0>
                let state = zeroState(qubitCount);

                // Predefine gate matrices
                const sqrt1_2 = 1/Math.sqrt(2);
                const I = [[c(1,0), c(0,0)], [c(0,0), c(1,0)]];
                const X = [[c(0,0), c(1,0)], [c(1,0), c(0,0)]];
                const Y = [[c(0,0), c(0,-1)], [c(0,1), c(0,0)]];
                const Z = [[c(1,0), c(0,0)], [c(0,0), c(-1,0)]];
                const H = [[c(sqrt1_2,0), c(sqrt1_2,0)], [c(sqrt1_2,0), c(-sqrt1_2,0)]];
                const S = [[c(1,0), c(0,0)], [c(0,0), c(0,1)]]; // phase i
                const T = [[c(1,0), c(0,0)], [c(0,0), c(Math.cos(Math.PI/4), Math.sin(Math.PI/4))]];

                // iterate column by column (time steps)
                for (let s = 0; s < gateSlotsPerQubit; s++) {
                    // collect gates in this column
                    const singleQubitGates = []; // {type, qubit}
                    const cnotControls = []; // qubit numbers with 'C'
                    const cnotTargets = []; // qubit numbers with 'X' (target)
                    const swapPositions = []; // qubits with 'SWAP'
                    const measurePositions = []; // qubits with 'M'

                    for (let q=0; q<qubitCount; q++){
                        const zone = document.querySelector(`.drop-zone[data-q="${q}"][data-s="${s}"]`);
                        if (!zone) continue;
                        const txt = zone.textContent.trim();
                        if (!txt) continue;
                        if (txt === 'C') cnotControls.push(q);
                        else if (txt === 'X' && zone.classList.contains('gate-cnot-target')) cnotTargets.push(q);
                        else if (txt === 'X') {
                            // standalone X gate (if not marked as cnot-target)
                            singleQubitGates.push({type:'X', qubit:q});
                        }
                        else if (txt === 'SWAP') swapPositions.push(q);
                        else if (txt === 'M') measurePositions.push(q);
                        else singleQubitGates.push({type: txt, qubit: q});
                    }

                    // 1) Apply single-qubit gates (order: H, X, Y, Z, S, T etc.)
                    for (const g of singleQubitGates) {
                        try {
                            switch (g.type) {
                                case 'H': state = applySingleQubitGate(state, qubitCount, g.qubit, H); break;
                                case 'X': state = applySingleQubitGate(state, qubitCount, g.qubit, X); break;
                                case 'Y': state = applySingleQubitGate(state, qubitCount, g.qubit, Y); break;
                                case 'Z': state = applySingleQubitGate(state, qubitCount, g.qubit, Z); break;
                                case 'S': state = applySingleQubitGate(state, qubitCount, g.qubit, S); break;
                                case 'T': state = applySingleQubitGate(state, qubitCount, g.qubit, T); break;
                                default:
                                    console.warn('Unknown single-qubit gate', g.type);
                            }
                            state = normalizeState(state);
                        } catch (e) {
                            console.error('Error applying single-qubit gate', g, e);
                        }
                    }

                    // 2) Apply CNOTs — pair controls and targets in order (user creates pairs by placing C and X in the same column)
                    const cn = Math.min(cnotControls.length, cnotTargets.length);
                    for (let i=0;i<cn;i++){
                        try {
                            state = applyCNOT(state, qubitCount, cnotControls[i], cnotTargets[i]);
                            state = normalizeState(state);
                        } catch (e) {
                            console.error('Error applying CNOT', e);
                        }
                    }

                    // 3) Apply SWAPs — pair SWAP positions sequentially (first with second, third with fourth)
                    for (let i=0; i+1 < swapPositions.length; i+=2) {
                        const a = swapPositions[i], b = swapPositions[i+1];
                        try {
                            state = applySWAP(state, qubitCount, a, b);
                            state = normalizeState(state);
                        } catch (e) {
                            console.error('Error applying SWAP', e);
                        }
                    }

                    // 4) Handle measurements in this column — collapse immediately for each measured qubit (one by one)
                    for (const mq of measurePositions) {
                        try {
                            const result = measureQubit(state, qubitCount, mq);
                            state = result.state;
                            // update the label for measured qubit in UI to show result (optional)
                            const qlineLabel = document.querySelector(`.qubit-line:nth-child(${mq+1}) .font-code`);
                            // Note: careful: simple label update might not select correct element because of DOM structure; we will update circuit labels visually elsewhere if needed.
                        } catch (e) {
                            console.error('Measurement error', e);
                        }
                    }
                } // end column loop

                // final probabilities & display
                showProbabilities(state, qubitCount);
                updateBloch(state, qubitCount);
            }

            function updateProbChart(reset = false) {
                probChart.innerHTML = '';
                if (qubitCount === 0) {
                    probChart.innerHTML = '<p class="text-gray-400 text-sm">Add qubits to start.</p>';
                    return;
                }
                const numStates = Math.pow(2, qubitCount);
                for (let i = 0; i < numStates; i++) {
                    const state = i.toString(2).padStart(qubitCount, '0');
                    const prob = (i === 0 && reset) ? 100 : 0;
                    const barHTML = `
                        <div class="flex items-center space-x-2">
                            <span class="text-gray-400 w-16">|${state}⟩</span>
                            <div class="w-full bg-gray-700 rounded-full h-4 overflow-hidden shadow-inner">
                                <div class="prob-bar-inner bg-cyan-500 h-4 rounded-full" style="width: ${prob}%;"></div>
                            </div>
                            <span class="text-white w-12 text-right">${prob.toFixed(1)}%</span>
                        </div>
                    `;
                    probChart.insertAdjacentHTML('beforeend', barHTML);
                }
            }

            // --- 4. NEW Interactive Canvas Background ---
            const canvas = document.getElementById('interactive-bg-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            let mouse = {
                x: null,
                y: null,
                radius: 150 // Area of influence for the mouse
            };

            window.addEventListener('mousemove', (event) => {
                mouse.x = event.x;
                mouse.y = event.y;
            });
            window.addEventListener('mouseout', () => {
                mouse.x = undefined;
                mouse.y = undefined;
            });


            let particlesArray = [];

            class Particle {
                constructor(x, y, directionX, directionY, size, color) {
                    this.x = x;
                    this.y = y;
                    this.directionX = directionX;
                    this.directionY = directionY;
                    this.size = size;
                    this.color = color;
                }
                
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                    ctx.fillStyle = 'rgba(0, 191, 255, 0.5)'; // accent-blue
                    ctx.fill();
                }

                update() {
                    if (this.x > canvas.width || this.x < 0) {
                        this.directionX = -this.directionX;
                    }
                    if (this.y > canvas.height || this.y < 0) {
                        this.directionY = -this.directionY;
                    }
                    this.x += this.directionX;
                    this.y += this.directionY;
                    this.draw();
                }
            }

            function init() {
                particlesArray = [];
                let particleCount = (canvas.height * canvas.width) / 9000;
                for (let i = 0; i < particleCount; i++) {
                    let size = (Math.random() * 2) + 1;
                    let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
                    let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
                    let directionX = (Math.random() * .4) - .2;
                    let directionY = (Math.random() * .4) - .2;
                    let color = 'rgba(0, 191, 255, 0.5)';
                    particlesArray.push(new Particle(x, y, directionX, directionY, size, color));
                }
            }

            function connect() {
                let opacityValue = 1;
                for (let a = 0; a < particlesArray.length; a++) {
                    for (let b = a; b < particlesArray.length; b++) {
                        let distance = ((particlesArray[a].x - particlesArray[b].x) * (particlesArray[a].x - particlesArray[b].x))
                                     + ((particlesArray[a].y - particlesArray[b].y) * (particlesArray[a].y - particlesArray[b].y));
                        
                        if (distance < (canvas.width / 7) * (canvas.height / 7)) {
                            opacityValue = 1 - (distance / 20000);
                            ctx.strokeStyle = 'rgba(0, 191, 255,' + opacityValue + ')'; // accent-blue
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                            ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
                            ctx.stroke();
                        }
                    }
                    
                    // Connect to mouse
                    if (mouse.x && mouse.y) {
                        let mouseDistance = ((particlesArray[a].x - mouse.x) * (particlesArray[a].x - mouse.x))
                                          + ((particlesArray[a].y - mouse.y) * (particlesArray[a].y - mouse.y));
                        
                        if (mouseDistance < (mouse.radius * mouse.radius)) {
                            opacityValue = 1 - (mouseDistance / (mouse.radius * mouse.radius));
                            ctx.strokeStyle = 'rgba(138, 43, 226,' + opacityValue + ')'; // accent-purple
                            ctx.lineWidth = 1.5;
                            ctx.beginPath();
                            ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                            ctx.lineTo(mouse.x, mouse.y);
                            ctx.stroke();
                        }
                    }
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                ctx.clearRect(0, 0, innerWidth, innerHeight);
                for (let i = 0; i < particlesArray.length; i++) {
                    particlesArray[i].update();
                }
                connect();
            }

            window.addEventListener('resize', () => {
                canvas.width = innerWidth;
                canvas.height = innerHeight;
                mouse.radius = 150;
                init();
            });

            init();
            animate();

        });
    </script>
</body>
</html>
